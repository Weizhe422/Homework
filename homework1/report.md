# 41343134

## 作業一 Ackermann Function

## 解題說明

用遞迴函式和非遞迴函式，計算 Ackermann 函數 $A(m,n)$ 的值。它需要兩個自然數作為輸入值，輸出一個自然數。它的輸出值增長速度非常高。以 m 和 n 為輸入的特殊遞迴函數，其結果會隨著 m, n 的增大而迅速增高。

### Ackermann 函數定義如下 :
| A(m,n)                 | 條件                  |
|------------------------|----------------------|
| n + 1                  | 當 m = 0             |
| A(m-1, 1)              | 當 n = 0             |
| A(m-1, A(m, n-1))      | 其他                 |

### 解題策略

1. 遞迴函式:
程式碼一直呼叫自己直到結束條件，結束的條件是所有遞迴測資 m == 0的時候。
2. 非遞迴函式:
  使用一個陣列模擬系統呼叫堆疊（stack），透過 while 迴圈重複執行並搭配 if 判斷，逐步展開遞迴關係。
   程式中設定 MAX_STACK = 100000 作為堆疊容量上限，可依實際需求調整大小。

## 程式實作

### IDE:
Microsoft Visual Studio Code C/C++

遞迴程式：

```cpp
#include <iostream>
using namespace std;
int ack(int m, int n) {
    if (m == 0) return n + 1; //if m=0,n+1
    else if (n == 0) return ack(m - 1, 1); //if n=0,A(m-1,n)
    else return ack(m - 1, ack(m, n - 1)); //otherwise , A(m-1,A(m,n-1))
}
int main() {
    int m, n;
    cout << "輸入 m 和 n : ";
    while (cin >> m >> n) {
        cout << "(" << m << ", " << n << ") = " << ack(m, n) << endl;
        cout << "輸入 m 和 n : ";
    }
    return 0;
}
```
非遞迴程式：

```cpp
#include <iostream>
#include <cstring> // for memset
using namespace std;

int ackermann(int m, int n) {
    // 設定一個足夠大的 stack 來模擬遞迴
    const int MAX_STACK = 100000; // 可依需求調整
    int stack[MAX_STACK];
    int top = 0;
    stack[top++] = m;

    while (top > 0) {
        m = stack[--top];
        if (m == 0) {
            if (top == 0) {
                return n + 1;
            }
            n = n + 1;
        }
        else if (n == 0) {
            stack[top++] = m - 1;
            n = 1;
        }
        else {
            stack[top++] = m - 1;
            stack[top++] = m;
            n = n - 1;
        }
    }
    return n;
}

int main() {
    int m, n;
    cout << "輸入 m 和 n :  ";
    while (cin >> m >> n) {
        cout << "(" << m << ", " << n << ") = " << ack(m, n) << endl;
        cout << "輸入 m 和 n : ";
    }
    return 0;
}
```

## 效能分析
遞迴函式：
1. 空間複雜度：當 m, n 較小時（如 m=3, n=5），遞迴層數可控；當 m, n 較大時，遞迴層數會極速膨脹，超過程式語言的棧上限，導致 Stack Overflow

   m=0、1、2 時，空間複雜度分別為 $O(1)$ 、 $O(n)$ 、 $O(n)$ 。m=3 時，空間複雜度約 $O(2ⁿ)$ 。m≥4 時，空間複雜度超越 $O(2ⁿ)$
   
2. 時間複雜度：對於小 m（0, 1, 2, 3），可以用簡單公式計算，複雜度為 $O(1)$ 、 $O(n)$ 或 $O(2ⁿ)$ ，但 m=4 以後，複雜度超過指數級，遠大於 $O(2ⁿ)$ 。

非遞迴函式：
1. 空間複雜度：m=3 時，空間複雜度 $O(n)$ ；m=4 時，空間複雜度 $O(2^n)$ ；m≥5 時，空間複雜度超越 O(2^(2^(...2^n)))（n層）
2. 時間複雜度：對於 m=3，複雜度約 $O(2^n)$ ；m=4，複雜度約 O(2^(2^(...2^n))) （n 層）。實際上，計算 Ackermann(4, 2) 就需要幾億次操作。

## 測試與驗證

### 測試案例 (遞迴/非遞迴)

| 測試案例 | 輸入參數 $m,n$ | 預期輸出 | 實際輸出 |
|----------|--------------|----------|----------|
| 測試一   | $m = 1,n = 1$ | 3        | 3        |
| 測試二   | $m = 2,n = 1$ | 5        | 5        |
| 測試三   | $m = 3,n = 2$ | 29        | 29        |
| 測試四   | $m = 3,n = 4$ | 125       | 125       |
| 測試五   | $m = 5,n = 1$ | 異常輸出  | 異常輸出  |

### 編譯與執行指令

```shell
$ g++ ack.cpp -std=c++17 -o ack.exe
$ .\ack.exe
輸入 m 和 n : 2 0
(2, 0) = 3
輸入 m 和 n : 2 1
(2, 1) = 5
```
### 結論

1. 使用堆疊模擬雖能避免遞迴爆棧，但無法改善 Ackermann 函數本身的超快速增長問題。
2. 遞迴與非遞迴的結果相同，但運算成本皆極高，輸入稍大就會導致時間與空間爆炸。  
3.Ackermann 函數的研究重點不在於「實際運算效率」，而在於「遞迴深度與計算極限」的理解。

## 申論及開發報告
1.定義即遞迴：Ackermann 函數的數學定義本身就是遞迴式，直接以遞迴撰寫能最清楚反映其結構。

2.程式邏輯清楚：使用 if/else 條件即可自然對應數學定義中三種情況，程式易讀且易於驗證。

3.教學與可讀性：遞迴版本能清楚展示函數呼叫過程與堆疊變化，具教學價值。

4.優缺點分析：優點：直觀、簡潔、易理解
               缺點：易導致 Stack Overflow、效能極低、不適合大型輸入

### 選擇遞迴方法的原因

1. 程式簡潔，容易實作與除錯：
   相較於非遞迴堆疊模擬，遞迴程式碼更短、更容易維護。
   只需透過 if / else 條件即可完整描述運算規則。

3.符合數學定義，程式邏輯直觀：
   Ackermann 函數的數學形式本身就是以遞迴方式定義的。
   程式結構清楚，邏輯自然，能完整呈現函數的原始意義
--------------------------------------------------------------------------------------------------------------------------------------------------------------------

## 作業一 之Powerset

## 解題說明

題目要求撰寫遞迴函式，輸出集合 𝑆
S 的所有子集合（即冪集合，powerset）。

### 解題策略
採動態配置（new/delete）或使用暫存陣列方式，每次遞迴時只保留當前路徑。可以節省二維陣列儲存所有子集合，避免浪費大量記憶體空間
## 程式實作

### IDE:
Microsoft Visual Studio Code C/C++

```cpp
#include <iostream>
#include <string>
using namespace std;

void pow(string A[], string s[], int i, int n, int t) {    // A[]:原集合 s[]:當前子集 i:目前處理到A[i] n:集合大小 t:當前子集大小
    if (i == n) {
        cout << "{";
        for (int j = 0; j < t; j++) {
            cout << s[j];
            if (j != t - 1) cout << ",";
        }
        cout << "}" << endl;
        return;
    }
    pow(A, s, i + 1, n, t);         // 不加入當前元素 A[i]，繼續處理下一個元素
    s[t] = A[i];                    // 加入當前元素 A[i] 到子集
    pow(A, s, i + 1, n, t + 1);     // 繼續處理下一個元素，子集大小 t 增加 1
}

int main() {
    int n;
    cout << "請輸入n個數 : ";
    cin >> n;
    string* A = new string[n];
    string* s = new string[n];
    cout << "請輸入集合元素 : ";
    for (int i = 0; i < n; i++) {
        cin >> A[i];
    }
    cout << "集合的冪集為:" << endl;
    pow(A, s, 0, n, 0);

    delete[] A;
    delete[] s;

    return 0;
}
```

## 效能分析
1.時間複雜度: O(n×2n)，因為共有 2𝑛2n 個子集合，每個子集合輸出最多需 𝑂(𝑛)O(n) 時間。
2.空間複雜度： 遞迴深度為 𝑂(𝑛)O(n)，若將所有子集合儲存起來則需 𝑂(𝑛×2𝑛)O(n×2n) 的記憶體空間。

## 測試與驗證

### 測試案例

| 測資 | 輸入參數 $n$ , 元素 | 預期輸出 | 實際輸出 |
|----------|--------------|----------|----------|
| 測試一   | $n = 1$ , a | () (a)       | () (a)       |
| 測試二   | $m = 2$ , a b | () (b) (a) (a,b)  | () (b) (a) (a,b)       |
| 測試三   | $m = 3$ , a b c | () (c) (b) (b,c) (a) (a,c) (a,b) (a,b,c) | () (c) (b) (b,c) (a) (a,c) (a,b) (a,b,c) |
### 編譯與執行指令

```shell
$ g++ pow.cpp -std=c++17 -o pow.exe
$ .\pow.exe
請輸入n個數 : 3
請輸入集合元素 : a b c
集合的冪集為:
{}
{c}
{b}
{b,c}
{a}
{a,c}
{a,b}
{a,b,c}
```

### 結論

1. 冪集合的子集數量隨 n 成長呈 2的n次方倍增加，因此當集合元素多時，程式的執行時間與記憶體消耗都會迅速上升。
2. 遞迴方式清楚反映「選或不選」的二分樹結構，程式邏輯直觀且容易實現。
3. 若需避免重複輸出，可在遞迴前先排序並過濾重複元素，進一步提升準確性。

## 申論及開發報告

### 選擇遞迴式回溯法的原因

1. 遞迴直觀與結構明確：

   每個元素僅需判斷「是否包含」即可形成完整的二叉遞迴樹，概念簡單、程式清楚。

2. 動態記憶體靈活性：
   
 使用動態陣列（new）或向量（vector）可依輸入大小彈性配置記憶體，避免浪費。
   
3. 擴充性高:
   程式可輕易修改以支援不同資料型態（字串、數字等），或改成非遞迴版本（如位元遮罩法）。
